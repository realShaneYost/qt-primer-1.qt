#!/usr/bin/env python3

import argparse
import os
import sys
import subprocess
from pathlib import Path
from textwrap import dedent


def create_requirements(dirname: str, envname: str) -> None:
  project_dir = Path(dirname).expanduser().resolve()
  venv_dir = project_dir / envname
  executable_path = venv_dir / "bin/python"
  requirements_path = project_dir / "requirements.txt"

  # Catch any runtime error that potentially breaks project creation
  try:
    result = subprocess.run(
      [str(executable_path), "-m", "pip", "freeze"], check=True, capture_output=True, text=True
    )
  except Exception as e:
    print(f"Warning: failed w/ error {e}")

  # write a friendly header so we never forget how to recreate our venv
  header = [
    f"# Generated by create.py for project {project_dir.name}. To recreate ...",
    f"# python3 -m venv venv && venv/bin/pip install -r requirements.txt",
    "",
  ]
  requirements_path.write_text("\n".join(header) + result.stdout, encoding="utf-8")

def create_virtual(dirname: str, envname: str) -> None:
  project_dir = Path(dirname).expanduser().resolve()
  venv_dir = project_dir / envname
  exe = venv_dir / "bin/python"

  # Validate project directory exists and the venv dir isn't already there
  if not project_dir.exists():
    print(f"Error: project directory '{project_dir}' does not exist.")
    sys.exit(os.EX_CANTCREAT)
  if venv_dir.exists():
    print(f"Error: virtual env '{venv_dir}' already exists.")
    sys.exit(os.EX_CANTCREAT)

  subprocess.run([sys.executable, "-m", "venv", str(venv_dir)], check=True)

  # Use the venv's interpreter directly, no source needed
  try:
    subprocess.run([str(exe), "-m", "pip", "install", "--upgrade", "pip"], check=True)
    subprocess.run([str(exe), "-m", "pip", "install", "PySide6"], check=True)
  # for now just be generic about it, probably should use CalledProcessError
  except Exception as e:
    print(f"Warning: failed w/ error {e}")
    sys.exit(os.EX_SOFTWARE)

  print(f"Created virtual environment '{venv_dir}' for project '{project_dir}'")


def create_project(dirname: str, filename: str) -> None:
  project_dir = Path(dirname).expanduser().resolve()
  script_path = project_dir / filename

  # We might want to add on to this later (e.g. class structure). For now this is good enough
  template = dedent(f"""\
    #!/usr/bin/env python3

    \"\"\"{project_dir.name}\"\"\"
    import argparse
    from PySide6 import QtCore, QtGui, QtWidgets


    def main(args: argparse.Namespace) -> None:
      print("argument:", args.argument)


    if __name__ == "__main__":
      parser = argparse.ArgumentParser(description="{project_dir.name}")
      parser.add_argument("-a", "--argument", action="store_true", help="an argument")
      main(parser.parse_args())
  """)

  # We might choose an existing project name so just exit if so
  project_dir.mkdir(parents=True, exist_ok=False)
  script_path.write_text(template, encoding="utf-8")
  script_path.chmod(0o755) # hard code this for now

  print(f"Created project folder: {project_dir}")
  print(f"Created executable:     {script_path}")


if __name__ == "__main__":
  parser = argparse.ArgumentParser(description="Pyside6 Qt Project Template Starter")
  parser.add_argument("-d", "--dirname", required=True, help="project directory")
  parser.add_argument("-f", "--filename", default="main.py", help="script filename")
  parser.add_argument("-v", "--venvname", default="venv", help="virtual env name")
  args = parser.parse_args()

  create_project(args.dirname, args.filename)
  create_virtual(args.dirname, args.venvname)
  create_requirements(args.dirname, args.venvname)
  sys.exit(os.EX_OK)
